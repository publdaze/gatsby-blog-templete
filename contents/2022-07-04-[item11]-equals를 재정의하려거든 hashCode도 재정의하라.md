---
date: '2022-06-23'
title: '[item3] private 생성자나 열거타입으로 싱글턴임을 보장하라'
categories: ['effective_java']
summary: '저자는 싱글턴을 만들 때 private 생성자나 열거타입(enum)으로 만들길 권장하고 있습니다. 그 이유에 대해 알아보겠습니다.'
thumbnail: './test.png'
---

> **equals를 재정의하려거든 hashCode도 재정의하라**

## hashCode?

`hashCode`는 간단하게 말하면 **해시 알고리즘에 의해 생성된 정수 값**입니다. 보통 성능상 이점을 얻기 위해 사용합니다. `String` 클래스와 함께 보면서 `hashCode`에 대해 이해해 보겠습니다.

> 해시 함수(hash function) 또는 해시 알고리즘(hash algorithm) 또는 해시함수알고리즘(hash 函數 algorithm)은 임의의 길이의 데이터를 고정된 길이의 데이터로 **매핑**하는 함수이다. 해시 함수에 의해 얻어지는 값은 해시 값, 해시 코드, 해시 체크섬 또는 간단하게 해시라고 한다. - 위키백과

여기서 중요한 점은 바로 **"매핑"**입니다. **어떤 길이의 데이터라도 고정된 데이터로 바뀐다는 점**과 **같은 값을 넣으면 같은 결과를 가진다**는 성질 때문에 빠르게 데이터를 검색할 수 있다는 특징도 있습니다.

<script src="https://gist.github.com/gusah009/d25d854df0ae93a4b1905d2662dda554.js"></script>

위 코드는 실제 `String`클래스에 정의된 `hashCode` 메서드 입니다. 전체 길이의 절반만큼 for문을 돌면서 각 문자의 ascii값을 hash코드로 추가해주고 있는 모습입니다. 코드를 보면 **31**을 곱해주고 있는 부분이 보입니다. 왜 그런 지 살펴보겠습니다.

### 1. 이 값이 짝수라면 곱셈의 결과가 오버플로우 됐을 때 해시 값이 유실된다.

짝수를 곱하게 되면 쉬프트 연산을 하게 되는데 이 과정에서 오른쪽 값이 0으로 채워지면서 정보의 손실이 일어납니다.

### 2. 31은 비트 이동과 뺄셈으로 곱셈을 대체할 수 있어서 성능을 향상 시킬 수 있다.

`i * 31`은 `(i << 5) - i`와 같습니다. 따라서 성능상 이점을 얻을 수 있습니다.

### 결론

결론은, 31이든, 59든 홀수이기만 하면 된다는 것입니다.

## 해쉬코드 규약

앞서 봤던 hash의 장점을 활용하려면 `hashCode`를 재정의 할 때 지켜야 할 규약이 있습니다. 만약 이 규약을 지키지 않는다면 `HashMap`이나 `HashSet`에서 문제를 일으킬 것입니다. 지켜야 할 규약은 아래와 같습니다.

1. `equals`비교에 사용되는 정보가 변경되지 않았다면, 객체의 `hashcode` 메서드는 몇번을 호출해도 항상 일관된 값을 반환해야 한다. (단, Application을 다시 실행한다면 값이 달라져도 상관없다.)
2. `equals`메서드 통해 두 개의 객체가 같다고 판단했다면, 두 객체는 똑같은 `hashcode` 값을 반환해야 한다.
3. `equals`메서드가 두 개의 객체를 다르다고 판단했다 하더라도, 두 객체의 `hashcode`가 서로 다른 값을 가질 필요는 없다. 단, 다른 객체에 대해서는 다른 값을 반환해야 해시테이블의 성능이 좋아진다.

중요한 부분은 두 번쨰 입니다. 앞서 [item10]에서 `equals`를 통해 물리적으로 다른 두 객체가 논리적으로 같다고 표현하는 것을 보았습니다. 하지만 재정의 되지 않은 `hashCode`는 주소값으로 비교하기 때문에 규약과 달리 서로 다른 값을 반환합니다. 따라서 반드시 `equals`를 재정의 했다면 `hashCode`도 재정의 해주어야 합니다.

## Ref.

[https://velog.io/@indongcha/hashCode%EC%99%80-31](https://velog.io/@indongcha/hashCode%EC%99%80-31)
